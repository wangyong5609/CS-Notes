# RPC通信原理

## RPC概述

RPC 的主要功能 目标是让构建分布式计算 （应用 ） 更容易 ， 是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议规范， 简单的来说就是**像调用本地服务一样调用远程服务**， 对开发者而言是透明的 。

### 为什么用RPC

- 分布式设计

- 部署灵活

- 解耦服务
- 扩展性强

### RPC的优势

- RPC框架一般使用长链接，不必每次通信都要3次握手，减少网络开销
- RPC框架一般都有注册中心， 有丰富的监控管理
- 发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作
- 协议私密，安全性较高
- rpc 能做到协议更简单内容更小，效率更高
- rpc是面向服务的更高级的抽象，支持服务注册发现，负载均衡，超时重试，熔断降级等高级特性

## RPC架构设计

![image-20231217111319868](./RPC%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86.assets/image-20231217111319868.png)

> 调用模块解决了我该调用哪个接口的问题
>
> 序列化解决了数据在网络中传输必须是二进制形式的问题
>
> 协议编解码节约了不同协议调用的问题
>
> 网络传输解决了网络点对点连接访问服务提供者具体实例问题

## RPC调用时序

![image-20231217192030899](./RPC%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86.assets/image-20231217192030899.png)

## RPC流程图

![image-20231217192149214](./RPC%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86.assets/image-20231217192149214.png)

## RPC框架实现要点

### 注册中心

**服务注册发现的作用**：在高可用的生产环境中，服务一般都以集群方式提供服务，集群里面的IP等重要参数信息可能随时会发生变化，节点也可能会动态扩缩容，客户端需要能够及时感知服务端的变化，获取集群最新服务节点的连接信息，而这些变化要求是要对调用方应用无感知的

![image-20231217192441204](./RPC%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86.assets/image-20231217192441204.png)

**常用的注册中心：**

- Zookeeper
- Nacos
- Consul

### 代理技术

**为什么要用代理**：RPC 的调用对用户来讲是透明的，内部核心技术采用的就是代理技术， RPC 会自动给接口生成一个代理实现，当我们在项目中注入接口的时候，运行过程中实际绑定的是这个接口生成的代理实现。在接口方法被调用的时候，它实际上是被生成代理类拦截到了，这样就可以在生成的代理类里面加入其他调用处理逻辑

**代理技术**：

- JDK动态代理
- ASM
- CGLIB
- bytebuddy
- Javassist

### 序列化技术

**序列化的作用**：在网络传输中，数据必须采用二进制形式，所以在 RPC 调用过程中，需要采用序列化技术，对入参和出参进行序列化与反序列化

**序列化技术选型要点**：

- 解析效率
- 压缩率，压缩后体积
- 扩展性， 兼容性
- 可读性，可调试
- 跨语言
- 通用性

**常见序列化框架**

- JDK原生序列化
- JSON
- Hessian2
- Protobuf

### 网络

#### RPC通信协议

通信协议规定了数据封装和传输的形式，为了传输效率，精简数据结构，一般会自研RPC通信协议

#### 系统IO

RPC 的调用过程中涉及到网络IO的操作，一般来说网络IO往往会成为系统的瓶颈所在，而不管上层应用如何使用，底层都是基于操作系统的IO模型。

IO模型：

- 同步阻塞IO
- 同步非阻塞IO
- IO多路复用
- 信号驱动IO
- 异步非阻塞IO



### 超时

时间轮算法：在时钟轮机制中，有时间槽和时钟轮的概念，时间槽就相当于时钟的刻度；而时钟轮就相当于指针跳动的一个周期，我们可以将每个任务放到对应的时间槽位上。

### 负载均衡

RPC Server 为了高可用，可用选择做集群，因此在 RPC CIient 端调用时要使用相应的均衡策略，这属于客户端负载均衡。

### 熔断限流

**熔断**：熔断器如同电力过载保护器。它可以实现快速失败，如果它在一段时间内侦测到许多类似的错误，会强迫其以后的多个调用快速失败，不再访问远程服务器，从而防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费 CPU 时间去等到长时间的超时产生。熔断器也可以使应用程序能够诊断错误是否已经修正，如果已经修正，应用程序会再次尝试恢复调用操作

**限流**：实际生产环境中，每个服务节点都可能由于访问量过大而引起一系列问题，就需要业务提供方能够进行自我保护，从而保证在高访问量、高并发的场景下，系统依然能够稔定，高效运行。限流器的作用是用来限制其请求的速率保护后台响应服务，以免服务过载导致服务不可用现象出现。