## 2.1.5 线程的概念

![image-20230825214652146](assets/image-20230825214652146.png)



![image-20230825215013339](assets/image-20230825215013339.png)

##   2.1.6 线程的实现方式和多线程模型

![image-20230825220343772](assets/image-20230825220343772.png)

## 2.1.7 线程的状态与转换

![image-20230825220526773](assets/image-20230825220526773.png)

![image-20230825221010721](assets/image-20230825221010721.png)

## 2.2.1 调度的概念、层次

![image-20230825221831890](assets/image-20230825221831890.png)

![image-20230825222021687](assets/image-20230825222021687.png)

## 2.2.2 进程调度的时机、切换与过程、方式

![image-20230826132542304](assets/image-20230826132542304.png)

## 2.2.3 调度器和闲逛线程

![image-20230826133127526](assets/image-20230826133127526.png)

![image-20230826133144903](assets/image-20230826133144903.png)

## 2.2.4 调度算法的评价指标

![image-20230826134025372](assets/image-20230826134025372.png)

## 2.2.5 调度算法（1）

![image-20230826134707891](assets/image-20230826134707891.png)

![image-20230826135009682](assets/image-20230826135009682.png)



![image-20230826140405474](assets/image-20230826140405474.png)

![image-20230826140807541](assets/image-20230826140807541.png)

![image-20230826141147300](assets/image-20230826141147300.png)

![image-20230826141731382](assets/image-20230826141731382.png)

![image-20230826141759576](assets/image-20230826141759576.png)

## 2.2.6 调度算法（2）

 ![image-20230826142624026](assets/image-20230826142624026.png)

![image-20230826143010674](assets/image-20230826143010674.png)

![image-20230826143101122](assets/image-20230826143101122.png)

![image-20230826150221138](assets/image-20230826150221138.png)

![image-20230826150328481](assets/image-20230826150328481.png)

![image-20230826150733252](assets/image-20230826150733252.png)

![image-20230826151728977](assets/image-20230826151728977.png)

## 2.2.7 调度算法（3）

![image-20230826152322119](assets/image-20230826152322119.png)

## 2.3.1 进程同步、进程互斥

![image-20230826153448805](assets/image-20230826153448805.png)

## 2.3.2 进程互斥的软件实现方法

![image-20230826163954550](assets/image-20230826163954550.png)

## 2.3.3 进程互斥的硬件实现方法

![image-20230826171024062](assets/image-20230826171024062.png)

## 2.3.4 互斥锁



## 2.3.5 信号量机制

![image-20230826173705624](assets/image-20230826173705624.png)

![image-20230826173800128](assets/image-20230826173800128.png)

## 2.3.6 用信号量实现进程互斥、同步、前驱关系

![image-20230826181917477](assets/image-20230826181917477.png)

 P和V（P、V分别是荷兰语的test(proberen)和increment(verhogen)；

同步就是一前一后关系，前面条件满足，才会做后面的事；所以P，V可以简单理解为减法，加法；

进程同步的技巧口诀是先V后P，就是先加后减，初始值一般为0，就像银行存款，你都没存钱，怎么取钱呢

进程互斥的技巧口诀是先P后V，假如互斥信号量是1，现在有一台空闲的取款机，一个人要取款，他占用了取款机，可用资源做减法，就是0，其他取钱的人都要排队等着，他取款完成以后，取款机空闲了，可用资源做加法，就是1，他后面的人就可以接着取钱了。

当代码访问临界资源时，代码所执行的区域是临界区。
也就是说，**如果代码在执行的时候，没有访问临界资源的话，那个区域就不是临界区**。

![image-20230826183932749](assets/image-20230826183932749.png)

## 2.3.7 生产者-消费者问题

![image-20230826203252282](assets/image-20230826203252282.png)

![image-20230826203358520](assets/image-20230826203358520.png)

## 2.3.8 多生产者-多消费者问题 

![image-20230826204643789](assets/image-20230826204643789.png)

## 2.3.9 吸烟者问题

![image-20230826205641714](assets/image-20230826205641714.png)

![image-20230826205713287](assets/image-20230826205713287.png)

## 2.3.10 读者写者问题

![image-20230826211900474](assets/image-20230826211900474.png)

![image-20230826212019274](assets/image-20230826212019274.png)

解决写进程“饿死“问题

![image-20230826212106138](assets/image-20230826212106138.png)

![image-20230826212132465](assets/image-20230826212132465.png)

## 2.3.11 哲学家进餐问题

![image-20230826214533886](assets/image-20230826214533886.png)

![image-20230826214604898](assets/image-20230826214604898.png)

## 2.3.12 管程

![image-20230826215602407](assets/image-20230826215602407.png)

![image-20230826220425920](assets/image-20230826220425920.png)

![image-20230826220449335](assets/image-20230826220449335.png)

## 2.4.1 死锁的概念

![image-20230827160413197](assets/image-20230827160413197.png)

![image-20230827160725977](assets/image-20230827160725977.png)

## 2.4.2 死锁的处理策略-预防死锁

![image-20230828203358245](assets/image-20230828203358245.png)

### 2.4.3 死锁的处理策略-避免死锁

![image-20230830200604485](assets/image-20230830200604485.png)

 ![image-20230830201821972](assets/image-20230830201821972.png)![image-20230830201740493](assets/image-20230830201740493.png)

![image-20230830201946451](assets/image-20230830201946451.png)

## 2.4.4 死锁的处理策略-检测和解除

![image-20230830202815919](assets/image-20230830202815919.png)

![image-20230830202957309](assets/image-20230830202957309.png)

![image-20230830203313911](assets/image-20230830203313911.png)

![image-20230830203401679](assets/image-20230830203401679.png)

