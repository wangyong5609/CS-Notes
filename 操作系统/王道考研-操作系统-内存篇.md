## 3.1.1 内存的基础知识

![image-20230830205430589](assets/image-20230830205430589.png)

![image-20230830210400473](assets/image-20230830210400473.png)

![image-20230830210706504](assets/image-20230830210706504.png)

![image-20230830210846949](assets/image-20230830210846949.png)

 

![image-20230830211301180](assets/image-20230830211301180.png)

![image-20230830211424778](assets/image-20230830211424778.png)

![image-20230830211610796](assets/image-20230830211610796.png)

## 3.1.2 内存管理的概念

![image-20230830212451765](assets/image-20230830212451765.png)

## 3.1.3 覆盖与交换

![image-20230830213101762](assets/image-20230830213101762.png)

PCB常驻内存，因为它需要记录进程放在外存的什么位置

![image-20230830213300599](assets/image-20230830213300599.png)

![image-20230830213408091](assets/image-20230830213408091.png)

![image-20230830213715282](assets/image-20230830213715282.png)

![image-20230830213806055](assets/image-20230830213806055.png)

## 3.1.4 连续分配管理方式

![image-20230903202918692](assets/image-20230903202918692.png)

![image-20230903202937254](assets/image-20230903202937254.png)

![image-20230903203053673](assets/image-20230903203053673.png)

内部碎片：比如一个程序占用内存10M，那么只有放入分区6中，分区6有12M，多出来的2M就是内部碎片

外部碎片：是指内存中的某些空闲分区由于太小而难以利用

![image-20230903203520159](assets/image-20230903203520159.png)

![image-20230903203653757](assets/image-20230903203653757.png)

![image-20230903203809309](assets/image-20230903203809309.png)

![image-20230903204009595](assets/image-20230903204009595.png)

如果从一块较大的空闲内存中分配一部分给进程，则需要修改空闲分区表

![image-20230903204349732](assets/image-20230903204349732.png)

如果经过动态分区分配算法处理以后，分配的空闲内存和进程大小一样，则需要删掉空闲分区表中记录

![image-20230903204729585](assets/image-20230903204729585.png)

如果进程结束后，回收区有相邻空间分区，则合并它们，更新空闲分区表

![image-20230903204945740](assets/image-20230903204945740.png)

如果回收区相邻位置没有空闲分区，则在空闲分区表新增一条记录

![image-20230903205450360](assets/image-20230903205450360.png)

## 3.1.5 动态分区分配算法

 找到就用 ![image-20230903210316096](assets/image-20230903210316096.png)

优先找最小的空闲内存分区

![image-20230903210826406](assets/image-20230903210826406.png)

优先找最大的空闲内存分区

![image-20230903211126068](assets/image-20230903211126068.png)

就近找空闲分区

![image-20230903211807806](assets/image-20230903211807806.png)

![image-20230903212018889](assets/image-20230903212018889.png)

## 3.1.6 基本分页存储管理的概念

![image-20230904210752596](assets/image-20230904210752596.png)

![image-20230904210947355](assets/image-20230904210947355.png)

![image-20230904212922962](assets/image-20230904212922962.png)

1 Byte = 8 bit, 这里一个内存块至少要20bit,不过计算机分配内存是以字节为单位，所以一个内存块至少需要3个字节

页号只在逻辑上存在，并没有分配物理内存，因为知道页表的起始内存地址和每个块号的大小，页号是顺序排列的，所以页号为i的的内存存放地址是：页表起始地址+ 块内存大小*i

![image-20230904215630612](assets/image-20230904215630612.png)

这里主要分清页面和页号，页面是一块空间，页号是这块空间的编号

![image-20230904220011327](assets/image-20230904220011327.png)

![image-20230905205845000](assets/image-20230905205845000.png)

![image-20230905205929337](assets/image-20230905205929337.png)

## 3.1.7 基本地址变换机构

![image-20230906202526303](assets/image-20230906202526303.png)

![image-20230906203200545](assets/image-20230906203200545.png)

页表长度M是指页表中有多少个页表项

越界中断 中的越界是指 访问的页号P 大于 页表长度 M

![image-20230906204128634](assets/image-20230906204128634.png)

![image-20230906205054015](assets/image-20230906205054015.png)

![image-20230906205339493](assets/image-20230906205339493.png)

## 3.1.8 具有快表的地址变换机构

 ![image-20230906211347750](assets/image-20230906211347750.png)

![image-20230906212708444](assets/image-20230906212708444.png)

![image-20230906213219760](assets/image-20230906213219760.png)

![image-20230906213619195](assets/image-20230906213619195.png)

![image-20230906213652086](assets/image-20230906213652086.png)

## 3.1.9 两级页表

![image-20230907202020792](assets/image-20230907202020792.png)

![image-20230907204034405](assets/image-20230907204034405.png)

![image-20230907205723411](assets/image-20230907205723411.png)

![image-20230907210342206](assets/image-20230907210342206.png)

## 3.1.10 基本分段存储管理方式

![image-20230907210708524](assets/image-20230907210708524.png)

 ![image-20230907210913595](assets/image-20230907210913595.png)

![image-20230907211500534](assets/image-20230907211500534.png)

16+32：16是段长，32是基址 

![image-20230907212420446](assets/image-20230907212420446.png)

在分段管理中，需要检查段内地址是否超过段长，因为每个分段的大小不同

![image-20230907213008471](assets/image-20230907213008471.png)

![image-20230907213235014](assets/image-20230907213235014.png)

![image-20230907213338561](assets/image-20230907213338561.png)

## 3.1.11 段分页管理方式

![image-20230907213615399](assets/image-20230907213615399.png)

 ![image-20230907214428911](assets/image-20230907214428911.png)

![image-20230907214832121](assets/image-20230907214832121.png)

因为各个分段长度不等，所以分页也不同，所以需要检查页号越界

![image-20230907215115051](assets/image-20230907215115051.png)

## 3.2.1 虛拟内存的基本概念



## 3.2.2_请求分页管理方式



## 3.2.3_页面置换算法



## 3.2.4_页面分配策略、抖动、工作集



## 3.2.5 内存映射文件



 
